# 과제#2 리눅스 명령어 조사
## 1. top
### top 명령어
  - 현재 OS의 상태를 나타내주는 CLI 어플리케이션. 메모리 사용량, CPU 사용량 등을나타내주며 top를 실행하는 동안에는 주기적인 업데이트로 실시간에 근접한 내용을 보여줍니다. 리눅스에서 top 명령어를 실행하면 아래와 같이 노출됩니다.
<img width="1280" height="375" alt="img1 daumcdn" src="https://github.com/user-attachments/assets/a021a524-e782-4cc2-8465-033fdbc4823b" />


### 요약 영역
  - 요약 영역은 top에서 상단에 위치합니다. 요약 영역은 전체 프로세스가 OS에 대해서 리소스를 어느정도 차지하고 있는지 알려줍니다. 요약 영역에 나타나는 대표적인 값은 시간, 유저, 로드 에버리지, 테스크, CPU, 메모리로 아래의 이미지를 보면 각 영역에 대해 나타내는 값이 어디에 위치하는지 알 수 있습니다.
<img width="1280" height="159" alt="img1 daumcdn" src="https://github.com/user-attachments/assets/3cdc0465-501f-43d1-bc15-54351312bd25" />


### 시스템 현재 시간, OS가 살아있는 시간, 유저 세션수(System time, uptime and user sessions)
  - 이미지의 가장 왼쪽 위를 보면 시스템 현재 시간, OS가 살아있는 시간, 그리고 유저의 세션수가 표시되는 영역이 있습니다. 가장 먼저 보이는 숫자가 시스템의 현재 시간압나다. 자세한 유저세션이 궁금하다면 who 명령어를 통해 알 수 있습니다.
<img width="1280" height="74" alt="img1 daumcdn" src="https://github.com/user-attachments/assets/0f085563-f046-4d1d-8521-f5f775891b97" />


### 로드 애버리지(Load Average)
  - 2번째 영역은 로드 애버리지 영역입니다. 해당 영역은 CPU Load의 이동 평균를 표시합니다. 앞에서 부터 1분, 5분, 그리고 15분에 대한 평균값입니다. CPU Load란 CPU가 수행하는 작업의 양 입니다. 리눅스에서는 실행되거나 대기중인 프로세스의 평균입니다. 싱글 코어일 경우 1.0의 값이 CPU 100%를 사용하고 있다는 의미입니다. 멀티 코어라면 해당 코어수 만큼 * N을 한 값이 CPU 100%를 사용한다는 의미가 됩니다. 만약 100%를 넘어간다면 CPU에서 처리하지 못하고 대기하고 중인 프로세스가 있다고 보시면됩니다.


### Tasks
  - 2번째 줄에는 Tasks에 관한 내용이 출력됩니다. Tasks는 현재 프로세스들의 상태를 나태내주는 영역입니다. Total은 전체 프로세스, running은 running 상태인 프로세스, sleeping은 대기상태인 process, stopped는 종료된 프로세스, zombies는 좀비상태인 프로세스의 수를 나타냅니다.


  - 프로세스는 일반적으로 IO 기반의 일(IO bound)과 CPU 기반의 일(CPU-bound)을 번갈아 가면서 수행하게 됩니다. 이러한 프로세스의 상태는 일반적으로 아래와 같습니다. IO 기반의 일을 하게 될 때는 CPU는 idle 타임에 들어가게 됩니다. 또한 프로세스 스케줄링 알고리즘에 의해 프로세스는 번갈아가면서 실행되게 됩니다. 이렇게 멀티테스킹 작업을 시도하는데 이때 프로세스에는 아래와 같은 상태의 변동이 있습니다.


 1. 실행(Runnable) - CPU에 의해서 명령어가 실행중인 Process
 2. 준비(Ready) - CPU의 명령어 실행을 기다리는 Process
 3. 대기(Waiting) - I/O operation이 끝나기를 기다리는 Process
 4. 종료(Terminated) - Ctrl + Z 등의 signal로 종료된 Process
 5. Zombie - Process는 root Process로 부터 뿌리내린 자식 Process의 형식으로 트리구조를 형성합니다. 이 때 부모가 먼저 종료된 다면 root process로 부터 닿을 수 없는 Process가 생깁니다. 이를 zombie process라고 부릅니다.
<img width="1280" height="527" alt="img1 daumcdn" src="https://github.com/user-attachments/assets/b375269c-99ea-4be3-91b0-28804174e8e8" />


### CPU 사용량
  - Tasks 아래 %Cpu(s)라는 영역이 있습니다. 이 영역은 CPU가 어떻게 사용되고 있는지 그 사용율을 보여주는 영역입니다. 모든 값의 총 합은 100% 이며 이를 퍼센테이지로 나누어서 보여줍니다. 각 요소는 아래와 같습니다.

us : 프로세스의 유저 영역에서의 CPU 사용률

sy : 프로세스의 커널 영역에서의 CPU 사용률

ni : 프로세스의 우선순위(priority) 설정에 사용하는 CPU 사용률

id : 사용하고 있지 않는 비율

wa : IO가 완료될때까지 기다리고 있는 CPU 비율

hi : 하드웨어 인터럽트에 사용되는 CPU 사용률

si : 소프트웨어 인터럽트에 사용되는 CPU 사용률

st : CPU를 VM에서 사용하여 대기하는 CPU 비율


### 메모리 사용량
  - %Cpu(s) 영역 아래에 메모리와 관련된 영역이 있습니다. 첫번째 줄은 RAM의 메모리 영역으로 Mem이라 표시되어있는 부분입니다. 그리고 아랫줄은 디스크를 메모리 처럼 이용하는 Swap 메모리 영역입니다. 일반적으로 Mem의 사용량이 거의 가득 찼을때 Swap 메모리 영역을 사용합니다. 이 영역은 디스크이기 때문에 RAM 메모리보다 속도가 많이 느린 단점을 가집니다.
  - buff/cache에서 buff는 buffers의 약자입니다. 이 값은 커널 버퍼에서 사용되는 메모리를 뜻합니다. cache는 Disk의 페이지 캐시를 말합니다. 즉, buff/cache는 IO와 관련되어 사용되는 버퍼에 사용되는 메모리를 말합니다. 이 메모리가 있으므로써 IO에 상대적으로 빠른 속도를 가질 수 있습니다. avail Mem은 swap 메모리를 사용하지 않고 사용할 수 있는 메모리의 크기를 말합니다.


### 디테일 영역
  - 디테일 영역에는 각 프로세스에 대한 상세한 내용이 나옵니다.
<img width="1280" height="230" alt="img1 daumcdn" src="https://github.com/user-attachments/assets/5f308091-685a-4bb4-95cc-4c42c58d7265" />

  - PID
    - PID는 프로세스 ID이며 프로세스를 구분하기 위한 겹치지않는 고유한 값입니다.
  - USER
    - 해당 프로세스를 실행한 USER 이름 또는 효과를 받는 USER의 이름입니다.
  - PR & NI
    - PR : 커널에 의해서 스케줄링되는 우선순위입니다.
    - NI : PR에 영향을 주는 nice라는 값입니다.
  - VIRT, RES, SHR, %MEM
    - 해당 필드들은 프로세스의 메모리와 관련있습니다.
    - VIRT : 프로세스가 소비하고 있는 총 메모리입니다. 프로그램이 실행중인 코드, heap, stack과 같은 메모리, IO buffer 메모리를 포함합니다.
    - RES : RAM에서 사용중인 메모리의 크기를 나타냅니다.
    - SHR : 다른 프로세스와의 공유메모리(Shared Memory)를 나타냅니다.
    - %MEM : RAM에서 RES가 차지하는 비율을 나타냅니다.
  - S : 프로세스의 현재 상태를 나타냅니다.
  - TIME+ : 프로세스가 사용한 토탈 CPU 시간
  - COMMAND : 해당 프로세스를 실행한 커맨드를 나타냅니다.


## 2. ps
### ps 명령어 및 옵션
  - ps 명령어는 Process State의 약자로 현재 실행 중인 프로세스와 상태를 출력하는 명령어입니다.
  - man ps를 사용 시 ps 명령어와 관련된 매뉴얼을 볼 수 있는데, ps 명령어의 옵션은 각 시스템 계열 System V(-), BSD(- 사용 안 함), GNU(--)마다 다른 표기법 및 출력을 가지고 있습니다. 보통 grep 명령어와 많이 사용됩니다.

### ps 명령어 출력 항목
  - USER (BSD), UID (System V)
    - 프로세스 소유자의 이름
  - PID
    - 프로세스의 식별 번호
  - PPID
    - 부모 프로세스의 PID
  - %CPU
    - CPU 사용 비율의 추정치 (BSD)
  - %MEM
    - Memory 사용 비율의 추정치(BSD)
  - VSZ
    - K 단위 또는 페이지 단위의 가상 메모리 사용량
  - RSS
    - 실제 메모리 사용량
  - TTY
    - 프로세스와 연결된 터미널
  - S (System V), STAT (BSD)
    - 현재 프로세스의 상태 코드
  - TIME
    - 총 CPU 사용 시간
  - COMMAND
    - 프로세스의 실행 명령행
  - STIME
    - 프로세스가 시작된 시간 혹은 날짜
  - C (System V), CP (BSD)
    - 짧은 기간 동안의 CPU 사용률
  - F
    - 플래그
  - PRI
    - 실제 실행 우선순위
  - NI
    - nice 우선순위 번호

### ps 명령어 옵션
  - -A
    - 모든 프로세스를 출력
  - a (BSD)
    - 터미널과 연관된 프로세스를 출력, x 옵션과 같이 사용하여 모든 프로세스를 출력할 때 사용
  - -a
    - 세션 리더를 제외하고 데몬 프로세스처럼 터미널에 종속되지 않은 모든 프로세스를 출력
  - -e
    - 커널 프로세스를 제외한 모든 프로세스를 출력
  - -f
    - 출력을 풀 포맷으로 표기 (유닉스 스타일)
    - UID, PID , PPID 등이 함께 표시
  - -l (System V), l (BSD)
    - 출력을 긴 포맷으로 표기
    - 프로세스의 정보를 길게 보여주는 옵션으로 우선순위와 관련된 PRI 값과 NI 값을 확인
  - -o
    - 출력 포맷을 지정
  - -M
    - 64비트 프로세스들을 출력
  - -m
    - 프로세스뿐만 아니라 커널 스레드도 출력
  - -p
    - 특정 PID를 지정하여 출력
  - -r
    - 현재 실행 중인 프로세스 출력
  - u (BSD)
    - 프로세스의 소유자를 기준으로 출력
  - -u [사용자]
    - 특정 사용자의 프로세스 정보를 출력, 사용자를 지정하지 않는다면 현재 사용자 기준으로 출력
  - x (BSD)
    - 데몬 프로세스처럼 터미널에 종속되지 않은 프로세스를 출력
  - -x
    - 로그인 상태에 있는 동안 아직 완료되지 않은 프로세스를 출력.
    - *유닉스 시스템은 사용자가 로그아웃한 뒤에도 임의의 프로세서가 계속 동작 가능 -> 해당 프로세서는 자신이 실행시킨 쉘이 없어도 계속 자신의 일을 수행하는 데 이 프로세스는 해당 옵션 없이는 확인이 불가능
   
## 3. jobs
### jobs 명령어
  - 리눅스에서 jobs 명령어는 현재 쉘 세션에서 실행 중이거나 일시 중지된 작업(프로세스)을 확인할 때 사용됩니다. 백그라운드나 포그라운드에서 실행되는 작업들을 목록으로 보여주며, 각 작업에 대한 상태 정보도 함께 제공합니다. 주로 작업 제어 명령어인 fg, bg, kill과 함께 사용되며, 이 명령어들은 특정 작업을 포그라운드로 전환하거나 백그라운드에서 실행하거나, 작업을 종료할 때 유용합니다.
  - jobs 명령어는 각 작업에 대해 작업 번호, 프로세스 ID, 작업 상태(Running, Stopped 등), 명령어 이름 등을 출력합니다.

### jobs 명령어 사용법
  - 기본적으로 jobs 명령어는 현재 세션에서 실행 중이거나 중단된 작업 목록을 출력합니다. 옵션 없이 사용하면 현재 활성화된 작업 목록이 표시됩니다.
    - -l: 각 작업의 프로세스 ID(PID)도 함께 출력합니다.
    - -p: 각 작업의 프로세스 ID만 출력합니다.
    - -n: 가장 최근에 상태가 변경된 작업만 출력합니다.
    - -r: 실행 중(Running)인 작업만 출력합니다.
    - -s: 일시 중지된 작업만 출력합니다.

### jobs 명령어의 주요 기능
  - jobs 명령어는 쉘 세션에서 실행 중이거나 일시 중지된 모든 작업을 확인할 수 있는 매우 유용한 도구입니다. 이를 통해 사용자는 각 작업의 작업 번호를 확인하고, 이를 기반으로 fg, bg, kill 명령어를 사용하여 작업을 포그라운드로 전환하거나 백그라운드로 전환, 또는 종료할 수 있습니다. jobs 명령어는 특히 다수의 작업을 동시에 처리할 때 효과적으로 관리할 수 있도록 도와줍니다.


## 4. kill
### kill 명령어 및 옵션
  - kill 명령어는 지정한 프로세스에 지정한 시그널을 보냅니다. 시스템에 문제가 생겨 해당 프로세스를 종료할 필요가 있을 경우 많이 사용됩니다. 단순 kill 명령어로 종료가 되지 않는 프로세스는 9 시그널을 보내어 강제로 종료시킵니다. ps 명령어를 사용하여 목표 프로세스의 정보를 확인할 수 있습니다.
    - kill [옵션 or 시그널] [프로세스 번호]: 해당 프로세스를 종료. kill -s [시그널 번호 or 이름] 을 사용하거나 kill -[시그널 번호 or 이름]도 사용이 가능
    - -s [시그널 번호 or 이름] -[시그널 번호 or 이름]: 보낼 시그널을 지정
    - -l: 시그널 목록을 출력

### ps 명령어와 kill 명령어 조합
  - ps 명령어의 결과를 이용해서 kill 명령어로 해당 프로세스(들)을 종료하는 게 가능합니다.
    - ps ax | grep [프로세스명] | awk '{print $1}' | xargs kill
